Psicologia das cores:

É o estudo de como as cores influenciam as emoções, os sentimentos e o comportamento das pessoas. É uma área da psicologia que se aplica em diversos contextos, como marketing, design, decoração e branding.

Representando Cores com CSS3:

Representação por nomes
É uma maneira simples e direta de especificar cores utilizando o próprio nome das cores ex:(black,white,red,blue,green,purple,gray).

Representação por códigos hexadecimais
São usados para representar cores utilizando 6 caracteres após o símbolo(#), onde cada par de caracteres representa a intensidade de vermelho, verde e azul respectivamente.

Representação por RGB(Red, Green, Blue)
As cores são representadas usando a notação RGB(red, green, blue), que utiliza valores entre 0 e 255 para cada cor prímaria. A função rgb() é usada para especificar uma cor, com os valores separados por vírgulas: rgb(red, green, blue). É também possível utilizar a função rgba() para incluir nível de opacidade (alpha), variando de 0 a 1.

Representação por HSL(Hue, Sturation, Luminosity)
Utilizando a função hsl(hue, sturation, luminosity). Essa função permite definir cores usando três parâmetros. hue(matiz, ou tom), saturation(saturação) e lightness (luminosidade). é considerada mais intuitiva para os humanos. É também possível utilizar a função hsla() para incluir nível de opacidade (alpha), variando de 0 a 1 onde 0 significa totalmente transparente e 1 significa totalmente opaco. 

Harmonia de cores

Círculo cromático

É uma ferramenta que organiza as cores do espectro visível em um círculo, facilitando a harmonização e a combinação de cores.

Como algo fica bonito?

Existem duas coisas muito importantes, simetria é muito importante pois cria uma comodidade visual, faz com que as pessoas achem seu site mais bonito, a outra coisa é a harmonia de cores.

Cores primárias 

Vermelho, amarelo e azul.

Cores secundárias

Laranja, violeta e verde.

Cores Terciárias

São todas as outras que são misturas das cores primárias e secundárias, sempre que for dar um nome para uma cor terciária, o primeiro nome é o da cor primária o segundo nome é o da cor secundária. EX:

Amarelo-esverdeado, amarelo-alaranjado, vermelho-alaranjado, vermelho-arroxeado, azul-arroxeado, azul-esverdeado.

Temperatura das cores

Se pegarmos o círculo cromatico e o dividirmos entre o amarelo e o amarelo esverdado, e o dividirmos também entre o violeta e vermelho-arroxeado, todo o que estiver do lado esquerdo são as cores frias, as que restaram do lado direito são as cores quentes.
Se no seu site você quiser referenciar algo frio, é rocomendado utilizar cores frias e vice-versa.

Paleta de cores

Algo muito difícil em um site é saber escolher uma boa paleta de cores.
Geralmente uma paleta de cores tem de 3 a 5 cores.
Se o seu cliente tem uma logo e a cor utilizada nela é muito marcante para marca, então eu vou utilizar tal cor como a primária no site.

Cores complementares

Tais cores que tem o maior contraste entre si, são pares de cores que se encontram em lados opostos do círculo cromático.

Cores análogas

Ao contrário das cores complementares são cores que não tem constraste tão grande entre elas, mas os diferentes tons são perceptíveis. são aquelas que estão próximas umas das outras dentro do círculo cromático e compartilham a mesma cor básica.

Cores análogas e uma complementar

Você pega as cores análogas e uma complementar a partir da cor básica.

Cores análogas relacionadas 

Cores análogas são três cores vizinhas, as relacionadas você vai pegar duas cores vizinhas e pular uma terceira para pegar uma quarta.

Cores intercaladas

Cores que estão localizadas com um espaço entre elas, criando um contraste mais forte do que as cores análogas (que estão lado a lado).

Cores triádicas

Você vai pegar uma cor, pular três, pegar mais uma, pular três e pegar mais uma formando um triângulo equilatero.

Cores em quadrado

Parecidas com as cores triádicas, mas ao invés de pular 3, pula duas formando no fim um quadrado perfeito.

Cores tetrádicas

São aquelas que formam um retângulo quando dispostas, ou seja, são quatro cores equidistantes entre si, criando dois pares de cores complementares.

Monocromia

Trabalha com uma cor única. 
Escolhe uma cor e modifica a saturação e brilho(hsl), formando outras cores a partir da mesma.

Nem todos tons pasteis são cores terceárias, mas cores terceárias tem tom pastel.

Paleta de cores

Utilizar o adobe.color.com / paletton.com / coolors.co

Como capturar cores da tela?

Faça o download da extensão Colorzilla.

Como criar degradê com CSS?

<style>
        * { /* Configurações globais das CSS */ 
            height: 100%;
        
        }
        body{
            background-image: linear-gradient(to right, #3F3F9E 20% , #793F9F , #A83B96 , #C72A53 , #CD3546 , #D37E3E , #D6AF38);
            background-attachment: fixed;
        }
</style>

Nesse caso foi feito o degradê do instagram.

Tag <main>: Em HTML, a tag <main> indica o conteúdo principal da página, ou seja, a área mais importante e relevante para o utilizador. Em CSS, o <main> não tem uma utilidade específica, mas pode ser usado para estilizar esse conteúdo principal, aplicando estilos como cores, fontes, margens e padding.

Tipografia

Tipografia é a arte e a técnica de organizar tipos de letra (fontes) para torná-los legíveis e atraentes visualmente. Envolve a escolha de fontes, tamanhos, espaçamento, alinhamento e outros elementos para criar uma composição harmoniosa. 

Anatomia do tipo

Refere-se ao estudo da estrutura e dos elementos que compõem um caractere tipográfico, também conhecido como fonte. Isso inclui entender as diferentes partes de uma letra, como a haste, o filete, a serifa entre outras, e como elas interagem para criar a forma e a legibilidade de um caractere.

Altura x e X

A letra x é o ponto de partida para construção das fontes, pois a altura do x minúsculo decidirá a altura base de todas as letras minusculas. Desconsiderando ascendentes(ex:b,k) e descendentes(ex:g,q).
E a altura das maiúsculas refere-se a altura da letra X, é a distância entre a linha base e o topo das letras maiúsculas.

Corpo

Somando todas as alturas, o topo das maiúsculas, até a base das descendentes é chamado de corpo, e quando for definida uma fonte precisamos saber a altura do corpo pois é ela que configuraremos nas CSS.

Serifa

É um pequeno traço ou prolongamento nas extremidades dos traços das letras (hastes, braços ou caudas). Sua principal importância reside em facilitar a leitura, conduzindo o olhar do leitor ao longo das linhas de texto e proporcionando uma continuidade visual que torna a leitura mais fluida e menos cansativa.

Anatomias geométricas

Vértice, filete, esporão, arco, terminal, haste.

Anatomias humanizadas

Pé, barriga, orelha, cauda, perna, braço, espinha, olho.

Glifos

Uma letra é um glifo.
Um símbolo é um glifo.

Fontes

Um conjunto de glifos formam uma fonte.

Família tipograficá 

São diferentes formas de representar o mesmo grifo.
podendo ser light, normal, seminegrito, negrito, extranegrito e etc...
Nem toda fonte tem todos os tipos, toda fonte tem normal.

Categoria das fontes

Serifadas: Tem serifa.
 
Sans-serif: Sem serifa, melhor para textos longos em sites de preferência para fontes não serifadas.(Se o texto longo for em folha de papel é preferível com serifa).

Mono-espaçadas: Podem ser com ou sem serifa, e todas os glifos tem o mesmo espaço.

Handwriting: Tenta imitar a escritura a mão.

Display: É aquela que não tem nenhuma caracteristicas das de cima, não se baseia em tamanho, não tem linha base, ela não se preocupa em obedecer regras anatômicas, são fontes comemorativas, podendo simular fontes de filmes e etc...

DICA: Na hora de ler é branco no fundo e preto na letra, principalmente para textos grandes.

Famílias de fonte com CSS

<style>
	body{
	   font-family: arial, helvetica, sans-serif;
}

h1, h2 {
	font-family: 'Times Ne Roman', Times, serif;	
}
</style>

Fontes alternativas

Nem sempre o dispositivo terá a fonte desejada.
Então declare múltiplas fontes(safe font combinations.)
Ex: Caso, não tenha arial, será testada helvetica, se não tiver helvetica, vai para sans-serif.
É importante por uma genérica no final para garantir.
Ex: sans-serif, serif.

Tamanho de fonte e suas medidas

Medidas absolutas
cm(centímetro), mm(milímetro), in(polegada), px(pixel), pt(ponto), pc(paica).

pt(ponto)= É a medida que você vê no word.

Medidas relativas
em(altura do M), ex(altura X de um fonte), rem(tipo o em só que relativo ao route), vw(largura da view-port), vh(altura da view-port), %(porcentagem.)

Para medidas do font-size é recomendado o uso do px(pixel) e em(altura do M maiúsculo) somente essas duas medidas.
Em fonte-size não pode ter espaço entre a medida e o número.           font-size: 1 px; errado
font-size: 1px; certo 
16px geralmente = 1em
16px é o tamanho natural de umá pagina, logo
2em = 32px
0.5em = 8px 

Peso, estilo e shorthand font

Para utilizar negrito, não é mais necessário a tag b.
Utilize font-weight: ...;

font-weight: bolder;
/* Pesos numéricos: 100, 200, 300, 400, 500, 600, 700, 800, 900 */ 
/* Pesos literais: lighter, normal, bold, bolder */
/* weight(peso), width(largura), height(altura) */

font-style: italic;
/* italic ou normal*/

text-decoration: underline;
/* Sublinhado */

}

h1{
font-family: 'work sans', sans-serif;
font-weight: bolder;
font-size: 3em;
font-style: italic;
        
/*Shorthand font

Vai condensar as configurações na seguinte ordem
            
- font-style -> font-weight -> font-size -> font-family

No lugar de usar as 4 linhas de cima, podemos utlizar a propriedade shorthand, existem vários shorthands que você pode utilizar.
            
Ficando assim: 
*/
}
h1{
font: italic bolder 3em 'work sans', sans-serif;             
}

h2{
font: bold 2em 'work sans';
}


Para que algumas dessas configurações funcionem é necessário preencher essa linha abaixo. E podemos preencher utlizando Google Fonts.
@import url(...);

Usando Google Fonts

Para ter acesso a fontes gratuitamente utilize o Google Fonts.

Para utilizar uma fonte tem que colocar o @import.
Todo @import tem que ser colocado embaixo do style, ou como primeira linha de um documento css separado e ele tem que estar fora de um seletor{isto é um seletor}.

No exemplo abaixo foram utilizadas três fontes diferentes.

<style>

@import url('https://fonts.googleapis.com/css2?family=Bad+Script&family=Permanent+Marker&family=Work+Sans:ital,wght@0,100..900;1,100..900&display=swap');

body{
font-family: "Work Sans", Arial, verdana, sans-serif;
font-size: 16px;
color: black;
} 

h1{
font-family: "Permanent Marker", sans-serif;
font-size: 3em;
font-weight: 100;
font-style: normal;
}

h2{
font-family: "Bad Script", sans-serif;
font-size: 2em;
}

</style>

Usando fontes externas baixadas

Existem muitas fontes no google fonts, mas as vezes seu cliente quer uma que não está lá, o que fazer nesse caso?

Podemos utilizar o dafont.com pra encontrar outras fontes externas.

Para as por no site utilizamos a regra @font-face, seguindo o exemplo abaixo.

<style> 
@font-face {
            font-family: 'Love';
            src: url('fontes/love larry ttf.ttf') format(truetype);
            font-weight: normal;
            font-style: normal;

            /*
            Tipos de format()
            - opentype (otf)
            - truetype (ttf)
            - embedded-opentype
            - truetype-aat (Apple Advanced typography)
            - svg
            */
}

Percebemos que à nova fonte foi atribuido o nome 'Love'.

h1{
font-family: 'Times New Roman', Times, serif;
font-size: 3em;
font-weight: normal;
}

Para utilizarmos devemos por o nome da nova fonte, no font-family, ficando.

h1{
font-family: 'Love', Times, serif;
font-size: 3em;
font-weight: normal;
}
</style>

Alinhamentos de textos com CSS

Basicamente temos 4 tipos de alimentos de textos:

text-align: left; Alinhamento do texto à esquerda.

text-align: right; Alinhamento do texto à direita.

text-align: center; Centralização do texto.

text-align: justify; Alinhamento do texto à esquerda e à direita.

O valor "center" alinha o texto no centro da tela, o valor "right" alinha o texto na parte direita da tela, o valor "left" alinha o texto na parte esquerda da tela.
O texto de parágrafos(p) normalmente tem um alinhamento nos dois lados, à esquerda e à direita que é a função fundamental do valor "justify", por isso o utilizamos.
Existe também uma Propriedade de Estilo chamada "text-indent", que é responsável por dar aquele recuo no início de um parágrafo: Geralmente colocamos o valor dessa propriedade como "30px" de recuo.

text-indent: 30px; Tamanho do espaço antes do parágrafo começar(margem).

Usando o id com CSS

Por padrão todo seletor é genérico.

O atributo id em HTML serve para identificar exclusivamente um elemento dentro de um documento. É usado para diversos fins, como: estilização com CSS, manipulação com JavaScript e criação de links de navegação (âncoras) dentro da página. 

Cada id deve ser único em um documento HTML. Isso permite que você possa referenciar esse elemento específico de forma precisa. 

Em HTML é id

<h1 id="principal">Criando sites com HTML e CSS</h1>

Em CSS é #

/*
Pode ser h1#principal{} ou #principal{}
*/
#principal{
text-align: center;
background-color: green;
color: white;
}

EM CSS o id é usado para criar estilos personalizados para elementos individuais. Por exemplo, #meuElemento { color: blue; } estiliza o elemento com o id "meuElemento". 

As diferenças entre id e class

Em HTML é class

Em CSS é .(ponto)

Diferença com class:

A class é usada para agrupar elementos que compartilham um mesmo estilo ou comportamento, enquanto o id identifica um único elemento. 

Não de nome as suas classes pela forma e sim pela funcionalidade.

É possível aplicar mais de uma class a um elemento.

Também é possivel por um id e uma class em um mesmo elemento, porém o id sobrepõe a configuração de class.

id>class>genérico.  há um regra de hierarquia, porém há uma herança. EX:

(h1 genérico)
h1{
    color: green;

}

(h1 com class)
.teste{
    color: brown;
}

(h1 com id)
h1#principal{
    text-align: center;
    background-color: green;
}

Neste exemplo a cor que o h1 terá sera a brown correspondendo a autoridade do class que é acima do genérico, e como o h1 com id não especificou uma cor, a cor final será brown pois virá como herança.
caso o h1 com id especifique uma cor, ela será implementada por ter a maior autoridade.

Pseudo-classes em CSS 

No HTML, temos a tag "<div></div>", ela não tem uma função específica, serve apenas para demarcar um espaço qualquer dentro da nossa página. Podemos escrever textos dentro das tag div's... Como padrão, se tiver mais de uma, as div's ficam dispostas uma em cada linha, uma embaixo da outra, sendo que elas ocupam uma área que pega a largura inteira do navegador, de ponta à ponta. Exemplo:

 <body>
    <div>01</div>
    <div>02</div>
    <div>03</div>
</body> 

Podemos mudar a altura e largura das div's com as Propriedades de Estilo "Height" e "Width", também conseguimos mudar a posição dos textos nas div's com a Propriedade text-align, sendo que podemos adicionar bordas às div's com a Propriedade "border" com o valor "solid"

Nota: Ao utilizar a Propriedade de Estilo "border", devemos primeiro inserir o valor da espessura da borda em px, depois o tipo de borda (ex: solid) e posteriormente a sua cor. Exemplo de shorthand para bordas em CSS:

" border: 1px solid black; "

Como foi dito anteriormente, por padrão as div's ficam alinhadas uma em cima da outra, mas se quisermos que fiquem uma do lado da outra, devemos usar a Propriedade de Estilo "display" com o valor "inline-block", que seria um alinhamento de bloco em linha, assim fica tudo na mesma linha.

Agora, referente à Pseudo-classes , elas precisam e são relativas a um elemento ou uma classe, elas são relacionadas ao ESTADO de um determinado ELEMENTO . No CSS, as Pseudo-classes são representadas por "dois pontos" ( : )

Para usar as funcionalidades de Pseudo-classes, no código CSS, devemos abrir um seletor personalizado para o elemento que queremos determinar um estado, digitando "dois pontos" ( : ) e especificando o estado desejado, abrindo chaves posteriormente. 

Alguns exemplos de ESTADOS de elementos (Pseudo-classes) são: Ativo, Marcado, Vazio, Habilitado e etc. 

Existe um estado (Pseudo-classe) chamado "hover" (hover é uma Pseudo-classe que é compatível com vários elementos), que significa: "quando eu passar o mouse por cima", quando estamos com alguma coisa por cima dele.

Exemplo de elemento com Pseudo-classe abaixo:  

div:hover {
            background-color: brown;
}

Uma coisa legal que pode ser feita é inserir parágrafos (<p>) dentro de div's. Isso é enquadrado como um elemento dentro de outro elemento, e nesses casos, o elemento que está dentro é considerado " filho " ( children ) daquele que está fora (pai).

Em seletores CSS, se quisermos personalizar os elementos que estão dentro de outros elementos ( children ), devemos indicar o elemento "pai" e usar o símbolo de maior " > " para indicar o elemento filho ( children ) imediato a ele. Exemplo:

div > p {
            display: none;
}

A propriedade de estilo " display " com o valor " none " do exemplo acima faz com que os parágrafos que estejam dentro de div's ( ">" children ) fiquem com sua exibição oculta. Algo interessante que pode ser feito após isso, utilizando a Pseudo-Classe " hover ", é fazer com que o texto escondido apareça ao passarmos o mouse em cima da div.

Para isso, abrimos um seletor para a div com a Pseudo-Classe hover (div:hover) e indicamos o seu filho (p) com o símbolo " > ", exemplo: " div:hover > p { " e inserimos dentro a Propriedade de Estilo " display " com o valor " block ". Dessa forma, ao passarmos o mouse sobre a div, o texto escondido contido na tag "p" filho irá aparecer. Exemplo:

div:hover > p {
            display: block;
            color: white;
            background-color: red;
            width: 300px;
}

Atalho para criar varias div.

div{$}*N(N = número de divs desejadas.)

Pseudo-elementos

Outro exemplo de ESTADOS de elementos (Pseudo-classes) são: visited e active

A pseudo-class visited é bastante usada em ancoras e links, ela serve pra ativar uma configuração de estilo quando uma unidade do elemento for visitada.

A pseudo-class active é um estado de elemento que serve para ativar uma configuração de estilo quando uma unidade de elemento for ativada, ou seja... Quando clicarmos nela, por exemplo.

Agora, referente aos pseudo-elementos, eles podem agir nas classes, nos elementos, nos id`s e etc... Eles mexem diretamente no CONTEÚDO PERIFÉRICO DO ELEMENTO. No CSS, os pseudo-elementos são representados por "dois pontos duplos"(::)

Suponha que queremos que todo link no final tenha um indicação de que é um link, podemos abrir um seletor personalizado para links e usar o pseudo-elemento "::after" para fazer isso.

Exemplo de uso de pseudo-elemento:

a::after{
	content:'⇦';
	color: darkgrey;
	font-weight: normal;
} 

O código acima faz com que manipulemos o conteúdo periférico posterior (pseudo-elemento "after" ) de links, a propriedade do estilo " content " detém o valor que foi determinado para aparecer logo em seguida de todo link que inserirmos no site(no caso foi uma seta para esquerda). Além disso as outras propriedades do estilo do exemplo configuram o estilo de cor e peso desse conteúdo periférico posterior.

Também existe o pseudo-elemento "before", que funciona como o 'after" mas de forma oposta, fazendo com que manipulemos o conteúdo periférico que antecede os elementos.

Nota: Conseguimos configurar pseudo-elementos e mexer em conteúdos periféricos quando usamos as class. Exemplo:

.especial::before{
	content: '⇨';
	color: darkgrey;
	font-weight: normal;
}

.especial::after {
            content: ' ⇦';
            color: darkgrey;
            font-weight: normal;
        }
O código acima utiliza pseudo-elementos para manipular conteúdo periférico de links que pertencem à class "especial".

No CSS, o sinal > representa o seletor de filho direto. Ele é usado para selecionar apenas os elementos que são filhos diretos de um elemento pai específico, sem considerar elementos descendentes mais profundos. (quando temos elementos dentro de elementos).

Modelos de Caixas: Primeiros Passos

Os conceitos do Modelo de Caixas ( Box Model ) são aplicáveis ao HTML e ao CSS. Se trata de conjuntos que irão facilitar muito na hora de organizarmos o design e as partes do nosso site.

Quando temos um documento HTML, tudo aquilo que é exibido na tela, é exibido em forma de caixa... De tal modo que a grande maioria das caixas na HTML podem estar uma dentro da outra. Dessa forma, podemos formar hierarquias de caixas.

Quando colocamos um elemento dentro do outro, o termo que descreve isso é o " ANINHAMENTO ", algo em forma de ninho, coisas que estão uma dentro da outra e assim por diante. Na prática, uma caixa seria todo elemento de um site visível na tela.

Considerando que todos os elementos de um site estão dentro de uma caixa, quando formatamos um elemento com o CSS através de seletores, na verdade estamos configurando a caixa que vai estar exibindo esse elemento.

Anatomia de caixas:

PARTE DE CONTEÚDO : Toda caixa possui um tamanho, que é chamado de " PARTE DE CONTEÚDO ", esse tamanho é especificado em duas medidas muito importantes, que são: Altura ( " height " ) e Largura ( " width " )

BORDA : Podemos traçar uma linha em volta da Parte de Conteúdo (que define o tamanho da caixa) e chamamos essa linha de " BORDA "... Sendo assim uma borda é uma linha que circunda o seu conteúdo. 

PADDING : Por padrão, a linha da Borda irá ficar muito próxima da Parte de Conteúdo , e se quisermos dar um distanciamento, devemos adicionar um espaço de " PADDING " (acolchoamento), que seria uma pequena lacuna entre a Parte de Conteúdo e a Borda , para dar aquela engordada no elemento, mantendo a nossa borda distante do conteúdo. 

MARGIN : Ao desenvolver um site, eventualmente iremos ter caixas uma embaixo da outra de forma seguida e, se uma dessas caixas estiver configurada com um espaçamento "padding", pode ser que elas fiquem muito próximas uma da outra e acabem "grudando" na borda do elemento de cima. Pensando nisso, podemos criar, além de um espaço interno (padding), um espaçamento EXTERNO logo após a borda , que seria um " MARGIN ".

OUTLINE/TRACEJADO : Outra coisa que podemos fazer dentro do margin (espaçamento externo), logo do lado de fora da borda, é criar um tracejado, que não seria uma segunda borda e sim uma área chamada de " OUTLINE " (contorno/traçado). 

Sendo assim, ainda referente à anatomia das caixas, todo elemento e consequentemente toda caixa, tem a " Parte de Conteúdo ", tem uma " Borda ", dessa borda para dentro, temos o " Padding ", da borda para fora temos o " Margin " e, ainda dentro do margin e fora da borda, temos a área do " Outline ".

Nota: Todas essas características anatômicas das caixas (tirando a Parte de Conteúdo) geralmente só irão se manifestar se forem previamente configuradas no seu código.

Tipos de caixa:

Basicamente existem dois tipos de caixa, as do tipo "box-level / block-level" e "inline-level".

box-level / block-level: Em uma caixa deste tipo o elemento sempre irá iniciar em uma nova linha e como padrão sempre ocupará a largura total da tela ou do elemento onde ele está contido(100% do viewport), sendo que irá pular para próxima linha antes de continuar o conteúdo posterior e aí sim inserir outros boxes. As caixas deste tipo são isoladas e independentes.

exemplos de tags do tipo box-level: <div> <p> <main> <video> <h1>-<h6>

inline-level: Já uma caixa do tipo "inline-level" não vai começar uma nova linha, e sim no ponto exato onde foram definidos, no meio de um parágrafo por exemplo.
E a largura dele vai ocupar apenas o tamanho relativo ao seu conteúdo de forma direta(em um parágrafo por ex) sem pular para linha de baixo.

exemplos de tags do tipo inline-level: <a> <span> <code> <strong> <em> <button>


User agent: Config básica do navegador

Modelo de Caixas na prática (pt.1)
 
Propriedades de borda:

largura	-> border-width: 10px;

estilo -> border-style: solid;  (sólida)
	     	      : dashed; (tracejada)
		      : dotted;	(pontilhada)
		      : double;	(dupla)
		      : groove;	(em 3d)

cor -> border-color: red;

Shorthand:
 
border: 10px solid red (largura, estilo, cor)

Propriedades de padding:

padding-top: 10px;    (de topo)
padding-right: 10px;  (à direita)
padding-bottom: 10px  (de baixo)
padding-left: 10px;   (à esquerda)

Shorthand: 
	
padding: 15px 10px 15px 10px; (sentido horário: top, right, bottom, left)
padding: 10px; 		      (os 4 lados iguais a 10px)
padding: 15px 10px;	      (cima e baixo 15px / esquerda e direita 10px)

		   
Acessar DevTools do Chrome: botão direito no corpo do site -> inspecionar

box-level = block-level

Modelos de Caixas na prática (pt.2)

PROPRIEDADES DE ESTILO DE CADA PARTE ANATÔMICA DE UMA CAIXA:

PROPRIEDADES - MARGIN: As principais Propriedades de Estilo para margin são: " margin-top " (margin da parte de cima de um elemento), " margin-right " (parte direita), " margin-bottom " (parte de baixo) e " margin-left " (parte esquerda) - O valor dessas propriedades geralmente é inserido em px.

Nota: Para centralizar um elemento (CAIXA) na tela, de forma automática , devemos usar a Propriedade de Estilo " margin " com o valor " auto ". Isso fará com que elementos (caixas) sejam centralizados horizontalmente de forma automática, mesmo que o tamanho da tela mude.

Como no "padding", também existe um SENTIDO/ORDEM correta PARA INSERIR as propriedades de margin descritas logo acima. A "direção" correta é: 

1) - Top  
2) - Right  
3) - Bottom 
4) - left

Exemplo:

margin-top: 10px;
margin-right: 10px;
margin-bottom: 10px;
margin-left: 10px;

É importante declarar nessa ordem, pois é necessário ser condizente com a direção e sentido padrão do Modelo de Caixas do DevTools , que segue a direção de um ponteiro de relógio.

Também podemos utilizar uma Shorthand para inserir e simplificar todas essas declarações de margin em uma única linha, exemplo: " margin: 15px 10px 10px 15px; "

OBSERVAÇÃO: Mesmo em shorthands como a do exemplo acima, os valores devem ser declarados na ordem orientada ( top, right, bottom e left ), para que consigamos nos nortear e especificar corretamente o espaçamento certo o para respectivo lado/sentido.

Se quisermos configurar os quatro lados do margin de uma só vez e constituir um margin igualitário (mesmo valor nos quatro lados), podemos simplesmente inserir uma única vez a Propriedade "margin" com o valor em px desejado, esse valor será inserido nos quatro lados do elemento automaticamente , exemplo: " margin: 10px; "

IMPORTANTE : Se quisermos centralizar um elemento (CAIXA) de forma automática, mas ainda assim , alterar o margin do sentido de cima (top) ou de baixo (bottom), devemos inserir a seguinte declaração shorthand: " margin: 10px auto 10px auto; " 

Também podemos colocar só dois valores em uma propriedade margin, exemplo: " margin: 10px 20px; " - Quando colocamos somente dois valores, significa que os sentidos de CIMA E DE BAIXO são representados pelo primeiro valor e os sentidos de ESQUERDA E DIREITA são representados pelo segundo valor .

PROPRIEDADES - OUTLINE: As principais Propriedades de Estilo para outline são: " outline-width " (espessura da outline), " outline-style " (estilo da outline) e " outline-color " (cor da outline).

Os valores mais utilizados para a Propriedade de Estilo que define o estilo de uma outline (outline-style), são: " solid " (linha sólida), " dashed " (outline tracejada), " dotted " (outline pontilhada), " double " (linha dupla) e o " groove " (outline "3d")

Sendo que podemos utilizar uma shorthand para inserir e simplificar todas essas declarações de outline em uma única linha, exemplo: " outline: 10px solid black; " (Siga a ordem de inserção de valores do exemplo na hora de usar uma shorthand, caso contrário não funcionará corretamente).

display: inline; É uma propriedade CSS que faz com que elementos apareçam lado a lado, na mesma linha, sem ocupar uma linha inteira. Em outras palavras, os elementos são renderizados como texto "inline", ou seja, como parte do fluxo natural do texto. 

display: block; É uma propriedade que define o comportamento de um elemento como um "bloco" na página, ocupando toda a largura disponível do seu elemento pai.

display: inline-block; É um valor da propriedade CSS display que permite que um elemento seja tratado como um elemento inline e um elemento de bloco ao mesmo tempo. Isso significa que o elemento se comportará como um elemento inline (ficará na mesma linha com outros elementos inline) e, ao mesmo tempo, você pode definir a sua largura e altura, características de um elemento de bloco. 

Grouping tags em HTML5

Sem valor semântico:

<div> ->   block
<span>	-> inline

Com valor semântico:

Header: A tag <header> em HTML define a seção de cabeçalho de um documento ou seção, geralmente contendo elementos introdutórios ou de navegação. Serve para identificar o título da página, logotipo, links de navegação e outras informações relevantes no topo do conteúdo. 

Nav: No HTML, o elemento <nav> representa uma seção de uma página que contém links de navegação, seja para outras páginas do site, seja para seções dentro da mesma página. Ele é utilizado para agrupar os principais links de navegação, como um menu de navegação principal, e ajuda na organização do conteúdo e na acessibilidade. 

Main: No HTML, o elemento <main> define o conteúdo principal de um documento ou aplicação. Este conteúdo deve ser o principal, ou seja, o que está diretamente relacionado ao tema central da página ou da aplicação. 
Em resumo, o elemento <main> é utilizado para indicar a parte mais importante e única da página, onde o conteúdo principal é apresentado, e não pode ser repetido em outras áreas do documento. 

Section: A tag <section> no HTML5 serve para delimitar seções lógicas e estruturais de um documento, agrupando conteúdo relacionado e com um título ou cabeçalho, como um capítulo de um artigo. É uma forma de organizar o conteúdo de forma que seja mais fácil para os navegadores e leitores compreenderem a estrutura do documento. 

Article: No HTML, o elemento <article> é usado para representar uma composição independente em um documento, página, aplicação ou site, ou que pode ser distribuída ou reutilizada de forma independente, como em sindicação. Essencialmente, é usado para marcar um conteúdo que faz sentido por si só. 

Aside: No HTML, o elemento <aside> é usado para definir conteúdo que está tangencialmente relacionado ao conteúdo principal da página, mas que não é essencial para o seu entendimento. Geralmente, é utilizado para exibir informações adicionais, como barras laterais, avisos, informações do autor, links relacionados ou até mesmo anúncios.

Footer: No HTML, o elemento <footer> serve para definir o rodapé de um documento ou de uma seção específica, geralmente localizada na parte inferior da página. Ele pode conter informações como direitos autorais, informações de contato, links úteis e outros elementos que encerram o conteúdo da página ou da seção.  

Sombra nas Caixas

A propriedade box-shadow em CSS permite adicionar sombras a elementos, criando um efeito de profundidade e destacando elementos. A sombra é definida com base em vários valores, como deslocamento horizontal e vertical, desfoque e cor. 

Shorthand

box-shadow: -6px 4px 1px 1px black;

Caixas com vértices arredondados

Podemos criar caixas com pontas arredondadas, caixas com vértices arredondados... Para fazer isso utilizamos a Propriedade de Estilo "border-radius".

Propriedades - border-radius: As principais Propriedades de Estilo para Vértices Arredondados (border-radius) são: 

border-top-left-radius (arredondamento da parte superior esquerda da box)

border-top-right-radius (arredondamento da parte superior direita da box)

border-bottom-right-radius (arredondamento da parte inferior direita da box)

border-bottom-left-radius (arredondamento da parte inferior esquerda da box) 

Existe um SENTIDO/ORDEM correta PARA INSERIR as propriedades border-radius descritas acima. A "direção" correta é: 

1) - Top Left - Superior Esquerda  
2) - Top Right - Superior Direita
3) - Bottom Right - Inferior Direita
4) - Bottom Left - Inferior Esquerda

Também podemos utilizar uma SHORTHAND para inserir e simplificar todas essas declarações de border-radius em uma única linha, exemplo: " border-radius: 15px 10px 15px 10px; "

Também podemos colocar só dois valores em uma propriedade border-radius, exemplo: " border-radius: 10px 20px; " - Quando colocamos somente dois valores, significa que os sentidos SUPERIOR ESQUERDO E INFERIOR DIREITO são representados pelo primeiro valor e os sentidos SUPERIOR DIREITO E INFERIOR ESQUERDO são representados pelo segundo valor.

NOTA: O design prima pela discrição, então cuidado para não exagerar ao utilizar bordas arredondadas.

Quando temos um elemento na forma QUADRADA, uma <div> com altura e largura de 100px por exemplo, podemos transformar esses elementos quadrados em um círculo com a Propriedade de Estilo "border-radius" com o valor "50%" ou"100px". 

Bordas decoradas

A função da propriedade border-image em CSS é permitir que você use uma imagem como borda em um elemento HTML. Ela substitui a borda padrão (linha sólida, tracejada, etc.) por uma imagem ou gradiente, definindo sua fonte, corte (fatia) e comportamento de repetição (stretch ou repeat).
 
Como funciona:

A border-image é uma propriedade abreviada que combina várias propriedades individuais:

border-image-source: Especifica a imagem a ser usada como borda (URL ou gradiente CSS). 

border-image-slice: Define como a imagem é cortada para criar a borda. Você pode especificar quantos pixels devem ser usados de cada lado da imagem. 

border-image-width: Define a largura da borda, indicando quantos pixels da imagem devem ser usados em cada lado. 

border-image-outset: Define a distância da borda em relação ao conteúdo do elemento. 

border-image-repeat: Define como a borda é repetida (stretch ou repeat).  

Ex: h1{
            border: 22px solid transparent;
            padding: 10px;
            margin: 10px;
            border-image-source: url('borda.png');
            border-image-slice: 27;
            border-image-repeat: repeat;
           
           
Shothand seguindo a mesma ordem, source, slice, repeat.
            /*Shorthand*/
            border-image: url('borda.png') 27 repeat ;
        } 

VARIÁVEIS EM CSS:

 É possível utilizar variáveis dentro do CSS. Isso não torna a linguagem CSS uma linguagem de programação... Ela ainda continua sendo uma linguagem de marcação, assim como o HTML. Toda linguagem de programação tem variáveis, mas nem toda linguagem que tem variável é uma linguagem de programação.

 As Variáveis GUARDAM VALORES para serem usados mais na frente no nosso projeto/programa. 

 Por que deveríamos usar variáveis em CSS? Porque isso facilita, e muito, o nosso processo de desenvolvimento e posteriormente a manutenção do projeto , caso desejemos alterar algo no futuro... Fora que tudo fica ainda mais organizado.

 Usando a Paleta de Cores de um projeto qualquer como exemplo, geralmente alguns desenvolvedores simplesmente fixam a Paleta de Cores (códigos das cores) de um site em um comentário no documento CSS, e copiam e colam esses códigos sempre que precisam alterar uma cor... Na realidade esse não é o modo mais adequado de se fazer isso e existe uma maneira muito melhor e prática de se obter um melhor resultado, com variáveis CSS.

 Para declarar variáveis em CSS, devemos criar uma Pseudo-classe especial dentro do documento CSS atual, que seria uma espécie de referência dentro desse documento.

 As variáveis CSS são definidas dentro da Pseudo-classe " root " ( :root {...} ). Essa pseudo-classe define as configurações para a " RAIZ DA ÁRVORE ", que vai servir para o documento inteiro . 

 Tudo que colocarmos e definirmos dentro dessa pseudo-classe será válido para todo o documento, já que essa pseudoclasse (root) tem uma especificidade muito alta, ou seja, aplicado ao HTML, :root representa o elemento <html> e é idêntico ao seletor html, abrangendo todo o projeto... Dessa forma, basicamente podemos criar Variáveis "Globais" dentro de root.

 Observação: Por exemplo, em linguagens de programação, normalmente temos uma "área principal", que é onde podemos declarar as nossas variáveis globais... No CSS, essa "área principal" é na Pseudo-classe root.

 Todas as Variáveis em CSS tem que começar com "dois traço" ( -- ), após isso é preciso dar um nome (de sua preferência) para essa variável, posteriormente inserindo o valor da variável (código da cor nesse caso). Exemplo:

:root {
    --cor0: #ebe5c5;
    --cor1: #83e1ab;
    --cor2: #3ddc84;
    --cor3: #2fa866;
    --cor4: #1a5c37;
    --cor5: #063d1e;
}

 Nota: Não cadastramos as cores branco e preto nas variáveis do exemplo, mas isso é opcional e se você quiser pode cadastrar... Já que branco e preto sempre vai estar em um site, independentemente da Paleta utilizada.

 IMPORTANTE: Referente ao nome que damos para as nossas variáveis, ele é de sua preferência e você pode nomear como no exemplo acima, mas você também pode nomear de acordo com a função da variável. Por exemplo, no caso das cores da nossa Paleta, podemos nomear cada cor (variável) com o seu respectivo encargo, exemplo: "cor-de-destaque", "cor-de-fundo" e etc.

 Recapitulando... Para declararmos variáveis CSS, devemos abrir um seletor para a pseudo-classe "root" (referência e raiz da árvore) no início do código CSS (logo após os códigos de regra) e posteriormente declarar as nossas variáveis ( -- ) dentro desse seletor. 

 Depois de declarar as suas variáveis "globais" de cor dentro do root, na hora de formatarmos um elemento , qualquer elemento que seja, ao invés de digitar ou copiar e colar um código de cor, simplesmente usamos o atalho "Ctrl + Espaço", avançamos até o fim da lista de sugestões e lá estará a nossa Paleta de Cores declarada no root (valores guardados por variáveis)... Posteriormente basta escolher a cor desejada e adicioná-la.

 Ao selecionar variáveis na lista de sugestões como valor da respectiva Propriedade, o VSC coloca a função "var(--ex-nome);" como o valor (também é possível digitar a especificação da variável ao invés de usar a lista).

 O legal das variáveis é que podemos pode usá-las em quaisquer elementos e depois, se um cliente pedir por exemplo, podemos facilmente trocar o tema do site inteiro só mudando o valor que está configurado na variável (dentro de root)... É tipo um CSS dentro do CSS, trocando o valor da variável global que está no :root, você troca no site inteiro... Tudo que foi configurado com essa cor/variável irá ser automaticamente adaptado, sem precisar modificar propriedade por propriedade, item por item...

 Lembrando que nos exemplos anteriores, usamos variáveis contendo valores de cores, mas ainda dentro do mesmo seletor root que abrimos, podemos também declarar variáveis de fontes de texto, tanto fontes padrão, externas ou locais... E tudo irá funcionar exatamente como as variáveis de cores. Exemplo:

:root {
    --fonte-padrao: Arial, Verdana, Helvetica, sans-serif;
    --fonte-destaque: 'Bebas Neue', sans-serif;
    --fonte-android: 'Android', sans-serif;
}
'Bebas Neue' e 'Android' são fontes externas e locais respectivamente, que foram configuradas como valor de variáveis.

 Observação: Ao iniciarmos a configuração CSS de um novo projeto, por uma questão de organização, é muito indicado que você vá abrindo os seletores de estilização CSS de acordo com a ordem das tags da estrutura HTML , assim os seletores CSS ficarão organizados ao invés de aglomerados e completamente desordenados, e na hora de fazer alguma alteração pontual você irá se nortear de forma muito mais fácil pelo código CSS.

Responsividade para sites

 Refere-se à capacidade de um site adaptar-se a diferentes tamanhos de tela e dispositivos, como computadores, tablets e smartphones, sem perder a legibilidade ou a usabilidade. A ideia é garantir que o site seja exibido de forma consistente e agradável, independentemente do dispositivo que o usuário está usando. 

main{
            background-color: aliceblue;
            padding: 20px;
            border-radius: 10px;

            min-width: 280px;
            max-width: 800px;
            margin: auto;
     }

 A propriedade max-width em CSS define a largura máxima que um elemento pode ter, impedindo que ele se expanda demais em telas maiores ou quando o conteúdo interno é muito grande. Ao definir max-width, o elemento não excederá a largura especificada, mesmo que haja espaço suficiente para se expandir.

A propriedade min-width em CSS define a largura mínima de um elemento. Garante que um elemento não fique menor que a largura especificada, mesmo que o conteúdo interno seja menor.  

<picture>
         <source media="(max-width:600px)" srcset="imagens/irina-blok-pq.jpg">
         <img src="imagens/irina-blok.jpg" alt="">
</picture>

max-width se refere a imagem "irina-blok-pq" . Significa que quando vc diminuir a janela e ela chegar a 600px vai aparecer a imagem que foi colocada no max-width. 

Enquanto vc estiver com a janela maior que 600px vai estar aparecendo a imagem dela grande que está na linha de baixo, quando a janela estiver 600px ou menos minimizada ela aparecerá a imagem 'irina-blok-pq'. Essa imagem se vc olhar no caminho dela está o 'pq' significa pequeno ou seja ele cortou ela para quando a janela estiver com 600px ou menos ela aparecer.

Seletores, filhos e descendentes

Quando devemos usar o sinal de maior ( " > " ) para manipular elementos que estão dentro de outros elementos (filho/children)? Talvez alguns de vocês estejam na dúvida, porque tem vezes que o Guanabara usa o sinal, e outras não... E às vezes, quando inserimos o sinal nos nossos seletores, as declarações simplesmente não tem efeito...

ESCLARECENDO:

Nesse caso, você precisa lembrar dos conceitos de COMBINADORES DE SELETORES, que nada mais é do que criar uma relação útil entre os seletores. 

Você usa o " > " quando quer indicar que deseja estilizar um FILHO DIRETO de um elemento. Segue um exemplo:

<header>
	<h1></h1>
	<p></p>
</header>

No caso do exemplo acima, o "p" é um filho direto da div especial <header>, e portanto é um elemento de Primeiro Nível. Da mesma forma, veja que o "h1" identicamente é um filho direto de header e portanto é um elemento de Primeiro Nível também. É como se <p> e <h1> fossem IRMÃOS. 

Mas quando você NÃO USA o " > ", você  quer indicar os elementos que não são necessariamente filhos, mas são DESCENDENTES. Veja outro exemplo: 

<main>
      <article>
	  <h1></h1>
      </article>
</main>

SELETOR NÃO SIMPLIFICADO PARA O EXEMPLO ACIMA: " main > article > h1 {...} ". H1 é filho direto de article, que é filho direto de main. 

Tem como simplificar? Sim. Nesse caso, perceba que h1 é descendente de main (como se fosse um NETO ), então você pode DEIXAR DE USAR o " > " sem problema nenhum, dessa forma estará indicando elementos que não são necessariamente filhos, e sim descendentes. Exemplo: 

MESMO SELETOR ANTERIOR, SÓ QUE SIMPLIFICADO: " main h1 {...} "

Obs.: Se tivéssemos criado o seletor simplificado do exemplo acima, mas com o sinal " > " ( ex: main > h1 {...} ), não funcionaria porque esse h1 NÃO É FILHO DIRETO do main, e sim neto. Sendo que o sinal de maior ( ">" ) serve apenas para indicar filhos diretos.

É por isso que o Guanabara não usa o sinal de maior (>) às vezes, ele está simplificando o seletor (quando possível).

Isso facilita muito, porque você não precisará de uma pancada de classes e deixa o seu código mais limpo. 

PROPRIEDADES DE ESTILO PARA LISTAS:

Segue algumas Propriedades de Estilo extras apresentadas no vídeo para usarmos dentro de seletores de listas ( ex.: ul {...} ):

Quando criamos uma lista dentro de outro elemento, dentro de um aside por exemplo, geralmente as "bolinhas" da lista (marcadores sequenciais no caso de listas ordenadas) irão ficar para fora do elemento pai (aside)... Para resolver isso e manter a lista inteira dentro do elemento pai, devemos utilizar a Propriedade de Estilo " list-style-position " com o valor " inside " (por padrão marcadores de listas são posicionados com o valor " outside "). Essa propriedade define a posição dos marcadores da lista e dessa forma as "bolinhas" ficarão para dentro do elemento pai.

Outra questão, às vezes temos uma lista com muitos itens, muito extensa... E queremos dividi-la em duas partes para manter uma formatação mais agradável... Para fazer isso, temos a Propriedade de Estilo " columns " com o valor " 2 ". Com isso iremos dividir a nossa lista em duas colunas (se quiser dividir em mais de duas colunas é só alterar o valor numérico da propriedade).

É possível trocar as "bolinhas" ou marcadores de listas por outro símbolo, um emoji por exemplo. Para fazer isso, devemos usar a Propriedade de Estilo " list-style-type "... Como valor dessa propriedade, devemos colocar entre aspas 'simples' o número do código do emoji que escolhermos (sem o "U+"), e após isso, para de fato carregar o emoji, adicionar uma contrabarra ( \ ) antes do código do emoji e ainda dentro das aspas 'simples'. Obs.: A troca de símbolos de lista não é 100% compatível com todos os navegadores.

Uma coisa que pode acontecer é o nosso símbolo ficar "grudado" no item da lista, para evitar isso é indicado acrescentar um "espaço" entre o emoji e o item de lista. Para fazer isso, ainda dentro das aspas 'simples' e DEPOIS do código do emoji, acrescente outra contrabarra ( \ ) e logo após isso o código " 00A0 " ou " 0020 " (comando de espaço ). Se você quiser, pode inserir mais de um espaço, é só repetir o processo. Obs.: Sempre que você quiser dar um "espaço" ou inserir emojis pelo CSS, para qualquer outro elemento e não somente listas, faça como foi orientado nesse texto. 

Exemplo geral:

ul {
    list-style-position: inside;
    columns: 2;
    list-style-type: '\1F5F8\00A0\00A0';
}

Nota: Ainda existem muitas outras Propriedades de Estilo para listas além dessas três apresentadas no vídeo e descritas nesse texto.

MARGIN NEGATIVA:

No nosso projeto, dentro da área " Saiba Mais " (aside), formatamos o nosso h3 de um jeito que parece que o subtítulo faz parte do topo da caixa. Para fazer isso, inicialmente atribuímos um destaque de cores ao subtítulo e adicionamos um pequeno padding de 10px no mesmo... 

O resultado desejado seria que a caixa do h3 crescesse para "fora" e ocupasse a exata forma do topo da caixa do aside, resultando no efeito descrito.

Para isso, configuramos as margins laterais e superior do nosso h3 com um valor negativo de -10px, dessa forma a caixa do h3 irá crescer para "fora" e ocupará a forma do topo da caixa aside. A margin (espaçamento externo) foi configurada com um valor negativo, na prática essa margin está indo para dentro e se expandindo de forma inversa, abrangendo o topo do aside. Uma mesma configuração com um valor positivo no margin não daria o mesmo efeito.

Para fechar, posteriormente é só fazer o arredondamento da parte de cima da caixa do h3, para ficar condizente com a parte inferior da nossa caixa aside.

Tornando um vídeo responsivo

PROPRIEDADE DE ESTILO - POSITION:

O posicionamento padrão de todo elemento no HTML é o "estático". Todo elemento estático é posicionado no canto superior esquerdo no corpo do documento ou do elemento onde ele está contido. Esta é a posição 0 de um elemento no corpo do documento.

A Propriedade de Estilo " position " é utilizada para determinar o posicionamento e hierarquia dos elementos na página do documento.

PROPRIEDADES AUXILIARES DO POSITION:

A Propriedade de Estilo "position" vem ACOMPANHADA e é usada em conjunto com quatro outras propriedades auxiliares (são propriedades e NÃO valores para position), que são: 

top - (topo) 

bottom - (baixo)

right - (direita)

left - (esquerda)

Essas quatro propriedades irão determinar a localização final do objeto, irão deslocar o elemento conforme for especificado.

Por exemplo, se usamos a propriedade "top" com o valor de 20px em um elemento, o mesmo vai se deslocar do topo num total de 20px para baixo.

VALORES DA PROPRIEDADE POSITION:

Para a propriedade position, é possível atribuir 5 valores, que são: static, relative, absolute, fixed e sticky.

Funções dos valores mais usados:

static - (estático):

O valor padrão da propriedade position é o static. Se não determinarmos nada, é esse valor que vai prevalecer por "debaixo dos panos". Ele não indica posicionamento algum, ou seja, é o valor para "nenhum posicionamento específico" do elemento. A função dele é manter a hierarquia de posicionamento conforme já estabelecido no documento HTML.

Isso significa que aquelas quatro outras propriedades já citadas (top, bottom, left e right) não funcionarão, não irão alterar a posição do elemento se usadas juntamente com esse valor... Visto que o position já está como "static" por padrão.

relative - (relativo):

O valor relative posiciona um elemento em relação à sua posição "normal"... Ou seja, as quatro propriedades auxiliares (top, bottom, left e right) vão fazer com que o elemento seja ajustado A PARTIR DA SUA POSIÇÃO ORIGINAL.

Após ter definido o tipo de position (relative nesse caso), a posição do elemento é definida através das quatro propriedades auxiliares do position: top, bottom, left e right. Que indicam a distância com relação ao topo, base, esquerda e direita, respectivamente, tomando como REFERÊNCIA DE POSICIONAMENTO (no caso do valor relative) a posição original do elemento. (se não configurarmos valores de posicionamento com as propriedades auxiliares, o elemento simplesmente fica no mesmo lugar)

absolute - (absoluto):

Um elemento com o valor absolute para position vai ser disposto, com as propriedades auxiliares, de forma relativa ao seu elemento pai... DESDE QUE ESSE ELEMENTO PAI TENHA UM POSITION COM UM VALOR DIFERENTE DE "STATIC" DEFINIDO!
 
Se o elemento pai não ter um position com um valor diferente de "static" definido, o valor absolute faz com que o elemento configurado " saia " da hierarquia estabelecida pelo HTML. 

Um elemento com o position absolute é disposto em relação ao elemento de nível superior mais próximo dele que possui um position com um valor diferente de "static" definido... E como já foi dito, caso não exista nenhum elemento hierarquicamente de nível superior (pai ou "avô") que tenha um position sem ser o "static" definido, o position absolute será absoluto ao corpo da página (body).

Na prática, em elementos do tipo filho com o pai sem a propriedade position, o valor absolute "transforma" filhos de elementos em FILHOS DA PÁGINA (body). Assim, é possível posicionarmos um elemento filho (transformado) em qualquer lugar da página (fora do pai), independentemente do que temos lá. Isso pode ser útil em casos que precisamos posicionar um alerta em nossa página, por exemplo, e não queremos "quebrar" o layout. ---

Dessa forma, note que o position absolute possui dois comportamentos diferentes, que se manifestam dependendo da configuração do elemento pai ou elemento de nível superior.

#video{
    background-color: green;
    margin: 0px -15px 30px -15px;
    padding: 20px;
    position: relative;
    padding-bottom: 56%;
}
#video > iframe{
    position: absolute;
    top: 5%;
    left: 5%;
    width: 90%;
    height: 90%;
}


Nota: Perceba que o Guanabara configurou o filho da div (iframe) com a declaração "position: absolute" e o pai (a div) com a declaração "position: relative"... Dessa forma o elemento filho (iframe) é posicionado, com as propriedades auxiliares, em relação ao seu pai (div).




